/*
 * Tempus Dominus v6.2.9 (https://getdatepicker.com/)
 * Copyright 2013-2022 Jonathan Peterson
 * Licensed under MIT (https://github.com/Eonasdan/tempus-dominus/blob/master/LICENSE)
 */ !function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).tempusDominus = {}) }(this, function (t) { "use strict"; t.Unit = void 0, (T = t.Unit || (t.Unit = {})).seconds = "seconds", T.minutes = "minutes", T.hours = "hours", T.date = "date", T.month = "month", T.year = "year"; let e = { month: "2-digit", day: "2-digit", year: "numeric", hour: "2-digit", minute: "2-digit", second: "2-digit" }, s = t => { switch (t) { case "date": return { dateStyle: "short" }; case "month": return { month: "numeric", year: "numeric" }; case "year": return { year: "numeric" } } }, i = t => { if (!t) return "h12"; let e = { hour: "2-digit", minute: "2-digit", numberingSystem: "latn" }, s = new o().setLocale(t); s.hours = 0; let i = s.parts(void 0, e).hour; if ("12" === i) return "h12"; if ("24" === i) return "h24"; s.hours = 23; let a = s.parts(void 0, e).hour; return "00" === i && "11" === a ? "h11" : "00" === i && "23" === a ? "h23" : void console.warn(`couldn't determine hour cycle for ${t}. start: ${i}. end: ${a}`) }; class o extends Date { constructor() { super(...arguments), this.locale = "default", this.nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,], this.leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335] } setLocale(t) { return this.locale = t, this } static convert(t, e = "default") { if (!t) throw Error("A date is required"); return new o(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()).setLocale(e) } static fromString(t, e) { return new o(t) } get clone() { return new o(this.year, this.month, this.date, this.hours, this.minutes, this.seconds, this.getMilliseconds()).setLocale(this.locale) } startOf(e, s = 0) { if (void 0 === this[e]) throw Error(`Unit '${e}' is not valid`); switch (e) { case "seconds": this.setMilliseconds(0); break; case "minutes": this.setSeconds(0, 0); break; case "hours": this.setMinutes(0, 0, 0); break; case "date": this.setHours(0, 0, 0, 0); break; case "weekDay": { if (this.startOf(t.Unit.date), this.weekDay === s) break; let i = this.weekDay; 0 !== s && 0 === this.weekDay && (i = 8 - s), this.manipulate(s - i, t.Unit.date); break } case "month": this.startOf(t.Unit.date), this.setDate(1); break; case "year": this.startOf(t.Unit.date), this.setMonth(0, 1) }return this } endOf(e, s = 0) { if (void 0 === this[e]) throw Error(`Unit '${e}' is not valid`); switch (e) { case "seconds": this.setMilliseconds(999); break; case "minutes": this.setSeconds(59, 999); break; case "hours": this.setMinutes(59, 59, 999); break; case "date": this.setHours(23, 59, 59, 999); break; case "weekDay": { this.endOf(t.Unit.date); let i = 6 + s; if (this.weekDay === i) break; this.manipulate(i - this.weekDay, t.Unit.date); break } case "month": this.endOf(t.Unit.date), this.manipulate(1, t.Unit.month), this.setDate(0); break; case "year": this.endOf(t.Unit.date), this.setMonth(11, 31) }return this } manipulate(t, e) { if (void 0 === this[e]) throw Error(`Unit '${e}' is not valid`); return this[e] += t, this } format(t, e = this.locale) { return new Intl.DateTimeFormat(e, t).format(this) } isBefore(t, e) { if (!e) return this.valueOf() < t.valueOf(); if (void 0 === this[e]) throw Error(`Unit '${e}' is not valid`); return this.clone.startOf(e).valueOf() < t.clone.startOf(e).valueOf() } isAfter(t, e) { if (!e) return this.valueOf() > t.valueOf(); if (void 0 === this[e]) throw Error(`Unit '${e}' is not valid`); return this.clone.startOf(e).valueOf() > t.clone.startOf(e).valueOf() } isSame(t, e) { if (!e) return this.valueOf() === t.valueOf(); if (void 0 === this[e]) throw Error(`Unit '${e}' is not valid`); return t = o.convert(t), this.clone.startOf(e).valueOf() === t.startOf(e).valueOf() } isBetween(t, e, s, i = "()") { if (s && void 0 === this[s]) throw Error(`Unit '${s}' is not valid`); let o = "(" === i[0], a = ")" === i[1]; return (o ? this.isAfter(t, s) : !this.isBefore(t, s)) && (a ? this.isBefore(e, s) : !this.isAfter(e, s)) || (o ? this.isBefore(t, s) : !this.isAfter(t, s)) && (a ? this.isAfter(e, s) : !this.isBefore(e, s)) } parts(t = this.locale, e = { dateStyle: "full", timeStyle: "long" }) { let s = {}; return new Intl.DateTimeFormat(t, e).formatToParts(this).filter(t => "literal" !== t.type).forEach(t => s[t.type] = t.value), s } get seconds() { return this.getSeconds() } set seconds(t) { this.setSeconds(t) } get secondsFormatted() { return this.parts(void 0, e).second } get minutes() { return this.getMinutes() } set minutes(t) { this.setMinutes(t) } get minutesFormatted() { return this.parts(void 0, e).minute } get hours() { return this.getHours() } set hours(t) { this.setHours(t) } getHoursFormatted(t = "h12") { return this.parts(void 0, { ...e, hourCycle: t }).hour } meridiem(t = this.locale) { return new Intl.DateTimeFormat(t, { hour: "numeric", hour12: !0 }).formatToParts(this).find(t => "dayPeriod" === t.type)?.value } get date() { return this.getDate() } set date(t) { this.setDate(t) } get dateFormatted() { return this.parts(void 0, e).day } get weekDay() { return this.getDay() } get month() { return this.getMonth() } set month(t) { let e = new Date(this.year, t + 1); e.setDate(0); let s = e.getDate(); this.date > s && (this.date = s), this.setMonth(t) } get monthFormatted() { return this.parts(void 0, e).month } get year() { return this.getFullYear() } set year(t) { this.setFullYear(t) } get week() { let t, e = Math.floor((this.computeOrdinal() - this.getUTCDay() + 10) / 7); return e < 1 ? e = this.weeksInWeekYear(this.year - 1) : e > this.weeksInWeekYear(this.year) && (e = 1), e } weeksInWeekYear(t) { let e = t - 1; return 4 == (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7 || 3 == (e + Math.floor(e / 4) - Math.floor(e / 100) + Math.floor(e / 400)) % 7 ? 53 : 52 } get isLeapYear() { return this.year % 4 == 0 && (this.year % 100 != 0 || this.year % 400 == 0) } computeOrdinal() { return this.date + (this.isLeapYear ? this.leapLadder : this.nonLeapLadder)[this.month] } } class a extends Error { } let n = "tempus-dominus"; class r { } r.NAME = n, r.dataKey = "td", r.events = new class t { constructor() { this.key = ".td", this.change = `change${this.key}`, this.update = `update${this.key}`, this.error = `error${this.key}`, this.show = `show${this.key}`, this.hide = `hide${this.key}`, this.blur = `blur${this.key}`, this.focus = `focus${this.key}`, this.keyup = `keyup${this.key}`, this.keydown = `keydown${this.key}` } }, r.css = new class t { constructor() { this.widget = `${n}-widget`, this.calendarHeader = "calendar-header", this.switch = "picker-switch", this.toolbar = "toolbar", this.noHighlight = "no-highlight", this.sideBySide = "timepicker-sbs", this.previous = "previous", this.next = "next", this.disabled = "disabled", this.old = "old", this.new = "new", this.active = "active", this.dateContainer = "date-container", this.decadesContainer = `${this.dateContainer}-decades`, this.decade = "decade", this.yearsContainer = `${this.dateContainer}-years`, this.year = "year", this.monthsContainer = `${this.dateContainer}-months`, this.month = "month", this.daysContainer = `${this.dateContainer}-days`, this.day = "day", this.calendarWeeks = "cw", this.dayOfTheWeek = "dow", this.today = "today", this.weekend = "weekend", this.timeContainer = "time-container", this.separator = "separator", this.clockContainer = `${this.timeContainer}-clock`, this.hourContainer = `${this.timeContainer}-hour`, this.minuteContainer = `${this.timeContainer}-minute`, this.secondContainer = `${this.timeContainer}-second`, this.hour = "hour", this.minute = "minute", this.second = "second", this.toggleMeridiem = "toggleMeridiem", this.show = "show", this.collapsing = "td-collapsing", this.collapse = "td-collapse", this.inline = "inline", this.lightTheme = "light", this.darkTheme = "dark", this.isDarkPreferredQuery = "(prefers-color-scheme: dark)" } }, r.errorMessages = new class t { constructor() { this.base = "TD:", this.failedToSetInvalidDate = "Failed to set invalid date", this.failedToParseInput = "Failed parse input field" } unexpectedOption(t) { let e = new a(`${this.base} Unexpected option: ${t} does not match a known option.`); throw e.code = 1, e } unexpectedOptions(t) { let e = new a(`${this.base}: ${t.join(", ")}`); throw e.code = 1, e } unexpectedOptionValue(t, e, s) { let i = new a(`${this.base} Unexpected option value: ${t} does not accept a value of "${e}". Valid values are: ${s.join(", ")}`); throw i.code = 2, i } typeMismatch(t, e, s) { let i = new a(`${this.base} Mismatch types: ${t} has a type of ${e} instead of the required ${s}`); throw i.code = 3, i } numbersOutOfRange(t, e, s) { let i = new a(`${this.base} ${t} expected an array of number between ${e} and ${s}.`); throw i.code = 4, i } failedToParseDate(t, e, s = !1) { let i = new a(`${this.base} Could not correctly parse "${e}" to a date for ${t}.`); if (i.code = 5, !s) throw i; console.warn(i) } mustProvideElement() { let t = new a(`${this.base} No element was provided.`); throw t.code = 6, t } subscribeMismatch() { let t = new a(`${this.base} The subscribed events does not match the number of callbacks`); throw t.code = 7, t } conflictingConfiguration(t) { let e = new a(`${this.base} A configuration value conflicts with another rule. ${t}`); throw e.code = 8, e } customDateFormatError(t) { let e = new a(`${this.base} customDateFormat: ${t}`); throw e.code = 9, e } dateString() { console.warn(`${this.base} Using a string for date options is not recommended unless you specify an ISO string or use the customDateFormat plugin.`) } deprecatedWarning(t, e) { console.warn(`${this.base} Warning ${t} is deprecated and will be removed in a future version. ${e}`) } throwError(t) { let e = new a(`${this.base} ${t}`); throw e.code = 9, e } }; let l, d = [{ name: "calendar", className: r.css.daysContainer, unit: t.Unit.month, step: 1 }, { name: "months", className: r.css.monthsContainer, unit: t.Unit.year, step: 1 }, { name: "years", className: r.css.yearsContainer, unit: t.Unit.year, step: 10 }, { name: "decades", className: r.css.decadesContainer, unit: t.Unit.year, step: 100 },]; class c { constructor() { this._currentCalendarViewMode = 0, this._viewDate = new o, this.minimumCalendarViewMode = 0, this.currentView = "calendar" } get currentCalendarViewMode() { return this._currentCalendarViewMode } set currentCalendarViewMode(t) { this._currentCalendarViewMode = t, this.currentView = d[t].name } get viewDate() { return this._viewDate } set viewDate(t) { this._viewDate = t, this.options && (this.options.viewDate = t) } refreshCurrentView() { this.currentView = d[this.currentCalendarViewMode].name } get isTwelveHour() { return ["h12", "h11"].includes(this.options.localization.hourCycle) } } class h { constructor() { this.optionsStore = l.locate(c) } isValid(e, s) { if (s !== t.Unit.month && this.optionsStore.options.restrictions.disabledDates.length > 0 && this._isInDisabledDates(e) || s !== t.Unit.month && this.optionsStore.options.restrictions.enabledDates.length > 0 && !this._isInEnabledDates(e) || s !== t.Unit.month && s !== t.Unit.year && this.optionsStore.options.restrictions.daysOfWeekDisabled?.length > 0 && -1 !== this.optionsStore.options.restrictions.daysOfWeekDisabled.indexOf(e.weekDay) || this.optionsStore.options.restrictions.minDate && e.isBefore(this.optionsStore.options.restrictions.minDate, s) || this.optionsStore.options.restrictions.maxDate && e.isAfter(this.optionsStore.options.restrictions.maxDate, s)) return !1; if (s === t.Unit.hours || s === t.Unit.minutes || s === t.Unit.seconds) { if (this.optionsStore.options.restrictions.disabledHours.length > 0 && this._isInDisabledHours(e) || this.optionsStore.options.restrictions.enabledHours.length > 0 && !this._isInEnabledHours(e)) return !1; if (this.optionsStore.options.restrictions.disabledTimeIntervals.length > 0) { for (let i of this.optionsStore.options.restrictions.disabledTimeIntervals) if (e.isBetween(i.from, i.to)) return !1 } } return !0 } _isInDisabledDates(e) { return !!this.optionsStore.options.restrictions.disabledDates && 0 !== this.optionsStore.options.restrictions.disabledDates.length && this.optionsStore.options.restrictions.disabledDates.find(s => s.isSame(e, t.Unit.date)) } _isInEnabledDates(e) { return !this.optionsStore.options.restrictions.enabledDates || 0 === this.optionsStore.options.restrictions.enabledDates.length || this.optionsStore.options.restrictions.enabledDates.find(s => s.isSame(e, t.Unit.date)) } _isInDisabledHours(t) { if (!this.optionsStore.options.restrictions.disabledHours || 0 === this.optionsStore.options.restrictions.disabledHours.length) return !1; let e = t.hours; return this.optionsStore.options.restrictions.disabledHours.find(t => t === e) } _isInEnabledHours(t) { if (!this.optionsStore.options.restrictions.enabledHours || 0 === this.optionsStore.options.restrictions.enabledHours.length) return !0; let e = t.hours; return this.optionsStore.options.restrictions.enabledHours.find(t => t === e) } } class p { constructor() { this.subscribers = [] } subscribe(t) { return this.subscribers.push(t), this.unsubscribe.bind(this, this.subscribers.length - 1) } unsubscribe(t) { this.subscribers.splice(t, 1) } emit(t) { this.subscribers.forEach(e => { e(t) }) } destroy() { this.subscribers = null, this.subscribers = [] } } class u { constructor() { this.triggerEvent = new p, this.viewUpdate = new p, this.updateDisplay = new p, this.action = new p, this.updateViewDate = new p } destroy() { this.triggerEvent.destroy(), this.viewUpdate.destroy(), this.updateDisplay.destroy(), this.action.destroy(), this.updateViewDate.destroy() } } let m = { restrictions: { minDate: void 0, maxDate: void 0, disabledDates: [], enabledDates: [], daysOfWeekDisabled: [], disabledTimeIntervals: [], disabledHours: [], enabledHours: [] }, display: { icons: { type: "icons", time: "fa-solid fa-clock", date: "fa-solid fa-calendar", up: "fa-solid fa-arrow-up", down: "fa-solid fa-arrow-down", previous: "fa-solid fa-chevron-left", next: "fa-solid fa-chevron-right", today: "fa-solid fa-calendar-check", clear: "fa-solid fa-trash", close: "fa-solid fa-xmark" }, sideBySide: !1, calendarWeeks: !1, viewMode: "calendar", toolbarPlacement: "bottom", keepOpen: !1, buttons: { today: !1, clear: !1, close: !1 }, components: { calendar: !0, date: !0, month: !0, year: !0, decades: !0, clock: !0, hours: !0, minutes: !0, seconds: !1, useTwentyfourHour: void 0 }, inline: !1, theme: "auto" }, stepping: 1, useCurrent: !0, defaultDate: void 0, localization: { today: "Go to today", clear: "Clear selection", close: "Close the picker", selectMonth: "Select Month", previousMonth: "Previous Month", nextMonth: "Next Month", selectYear: "Select Year", previousYear: "Previous Year", nextYear: "Next Year", selectDecade: "Select Decade", previousDecade: "Previous Decade", nextDecade: "Next Decade", previousCentury: "Previous Century", nextCentury: "Next Century", pickHour: "Pick Hour", incrementHour: "Increment Hour", decrementHour: "Decrement Hour", pickMinute: "Pick Minute", incrementMinute: "Increment Minute", decrementMinute: "Decrement Minute", pickSecond: "Pick Second", incrementSecond: "Increment Second", decrementSecond: "Decrement Second", toggleMeridiem: "Toggle Meridiem", selectTime: "Select Time", selectDate: "Select Date", dayViewHeaderFormat: { month: "long", year: "2-digit" }, locale: "default", hourCycle: void 0, startOfTheWeek: 0, dateFormats: { LTS: "h:mm:ss T", LT: "h:mm T", L: "MM/dd/yyyy", LL: "MMMM d, yyyy", LLL: "MMMM d, yyyy h:mm T", LLLL: "dddd, MMMM d, yyyy h:mm T" }, ordinal: t => t, format: "L LT" }, keepInvalid: !1, debug: !1, allowInputToggle: !1, viewDate: new o, multipleDates: !1, multipleDatesSeparator: "; ", promptTimeOnDateChange: !1, promptTimeOnDateChangeTransitionDelay: 200, meta: {}, container: void 0 }; function y(t, e) { if (t.constructor.name === o.name) return t; if (t.constructor.name === Date.name) return o.convert(t); if ("string" == typeof t) { let s = o.fromString(t, e); return "null" === JSON.stringify(s) ? null : s } return null } function g(t, e, s) { "string" == typeof t && "input" !== e && r.errorMessages.dateString(); let i = y(t, s); return i || r.errorMessages.failedToParseDate(e, t, "input" === e), i } function v(t, e, s, i) { Array.isArray(e) || r.errorMessages.typeMismatch(t, s, "array of DateTime or Date"); for (let o = 0; o < e.length; o++) { let a = e[o], n = g(a, t, i); n || r.errorMessages.typeMismatch(t, typeof a, "DateTime or Date"), n.setLocale(i?.locale ?? "default"), e[o] = n } } function S(t, e, s) { (!Array.isArray(e) || e.some(t => "number" != typeof t)) && r.errorMessages.typeMismatch(t, s, "array of numbers") } function f(t) { return ({ value: e, providedType: s, localization: i }) => { let o = g(e, t, i); if (void 0 !== o) return o.setLocale(i.locale), o; r.errorMessages.typeMismatch(t, s, "DateTime or Date") } } function w(t) { let e = f(t); return t => void 0 === t.value ? t.value : e(t) } function b(t, e, s) { return ({ value: i, providedType: o }) => void 0 === i ? [] : (S(t, i, o), i.some(t => t < e || t > s) && r.errorMessages.numbersOutOfRange(t, e, s), i) } function D(t) { return b(t, 0, 23) } function k(t) { return ({ value: e, providedType: s, localization: i }) => void 0 === e ? [] : (v(t, e, s, i), e) } function C(t) { return ({ value: e, path: s }) => (t.includes(e) || r.errorMessages.unexpectedOptionValue(s.substring(1), e, t), e) } let $ = Object.freeze({ defaultDate: f("defaultDate"), viewDate: f("viewDate"), minDate: w("restrictions.minDate"), maxDate: w("restrictions.maxDate"), disabledHours: D("restrictions.disabledHours"), enabledHours: D("restrictions.enabledHours"), disabledDates: k("restrictions.disabledDates"), enabledDates: k("restrictions.enabledDates"), daysOfWeekDisabled: b("restrictions.daysOfWeekDisabled", 0, 6), disabledTimeIntervals({ key: t, value: e, providedType: s, localization: i }) { if (void 0 === e) return []; Array.isArray(e) || r.errorMessages.typeMismatch(t, s, "array of { from: DateTime|Date, to: DateTime|Date }"); let o = e; for (let a = 0; a < o.length; a++)Object.keys(o[a]).forEach(e => { let s = `${t}[${a}].${e}`, n = o[a][e], l = g(n, s, i); l || r.errorMessages.typeMismatch(s, typeof n, "DateTime or Date"), l.setLocale(i.locale), o[a][e] = l }); return o }, toolbarPlacement: C(["top", "bottom", "default"]), type: C(["icons", "sprites"]), viewMode: C(["clock", "calendar", "months", "years", "decades",]), theme: C(["light", "dark", "auto"]), meta: ({ value: t }) => t, dayViewHeaderFormat: ({ value: t }) => t, container: ({ value: t, path: e }) => (t && !(t instanceof HTMLElement || t instanceof Element || t?.appendChild) && r.errorMessages.typeMismatch(e.substring(1), typeof t, "HTMLElement"), t), useTwentyfourHour({ value: t, path: e, providedType: s, defaultType: i }) { if (r.errorMessages.deprecatedWarning("useTwentyfourHour", 'Please use "options.localization.hourCycle" instead'), void 0 === t || "boolean" === s) return t; r.errorMessages.typeMismatch(e, s, i) }, hourCycle: C(["h11", "h12", "h23", "h24"]) }), E = ({ value: t, defaultType: e, providedType: s, path: i }) => { switch (e) { case "boolean": return "true" === t || !0 === t; case "number": return +t; case "string": return t.toString(); case "object": return {}; case "function": return t; default: r.errorMessages.typeMismatch(i, s, e) } }; class M { static deepCopy(t) { let e = {}; return Object.keys(t).forEach(s => { let i = t[s]; if (i instanceof o) { e[s] = i.clone; return } if (i instanceof Date) { e[s] = new Date(i.valueOf()); return } e[s] = i, "object" != typeof i || i instanceof HTMLElement || i instanceof Element || Array.isArray(i) || (e[s] = M.deepCopy(i)) }), e } static objectPath(t, e) { return ("." === t.charAt(0) && (t = t.slice(1)), t) ? t.split(".").reduce((t, e) => M.isValue(t) || M.isValue(t[e]) ? t[e] : void 0, e) : e } static spread(t, e, s = "", i) { let o = M.objectPath(s, m), a = Object.keys(t).filter(t => !Object.keys(o).includes(t)); if (a.length > 0) { let n = M.getFlattenDefaultOptions(), l = a.map(t => { let e = `"${s}.${t}" in not a known option.`, i = n.find(e => e.includes(t)); return i && (e += ` Did you mean "${i}"?`), e }); r.errorMessages.unexpectedOptions(l) } Object.keys(t).filter(t => "__proto__" !== t && "constructor" !== t).forEach(a => { "." === (s += `.${a}`).charAt(0) && (s = s.slice(1)); let n = o[a], r = typeof t[a], l = t[a]; if (null == l) { e[a] = l, s = s.substring(0, s.lastIndexOf(`.${a}`)); return } "object" != typeof n || Array.isArray(t[a]) || n instanceof Date || M.ignoreProperties.includes(a) ? e[a] = M.processKey(a, l, r, typeof n, s, i) : M.spread(t[a], e[a], s, i), s = s.substring(0, s.lastIndexOf(`.${a}`)) }) } static processKey(t, e, s, i, o, a) { var n; return ($[(n = { key: t, value: e, providedType: s, defaultType: i, path: o, localization: a }).key] || E)(n) } static _mergeOptions(t, e) { let s = M.deepCopy(e), i = e.localization?.locale !== "default" ? e.localization : t?.localization || m.localization; return M.spread(t, s, "", i), s } static _dataToOptions(t, e) { let s = JSON.parse(JSON.stringify(t.dataset)); if (s?.tdTargetInput && delete s.tdTargetInput, s?.tdTargetToggle && delete s.tdTargetToggle, !s || 0 === Object.keys(s).length || s.constructor !== DOMStringMap) return e; let i = {}, o = t => { let e = {}; return Object.keys(t).forEach(t => { e[t.toLowerCase()] = t }), e }, a = (t, e, s, i) => { let n = o(s)[t[e].toLowerCase()], r = {}; return void 0 === n || (s[n].constructor === Object ? (e++, r[n] = a(t, e, s[n], i)) : r[n] = i), r }, n = o(e); return Object.keys(s).filter(t => t.startsWith(r.dataKey)).map(t => t.substring(2)).forEach(t => { let o = n[t.toLowerCase()]; if (t.includes("_")) { let r = t.split("_"); void 0 !== (o = n[r[0].toLowerCase()]) && e[o].constructor === Object && (i[o] = a(r, 1, e[o], s[`td${t}`])) } else void 0 !== o && (i[o] = s[`td${t}`]) }), this._mergeOptions(i, e) } static _dateTypeCheck(t, e) { return y(t, e) } static _typeCheckDateArray(t, e, s, i) { return v(t, e, s, i) } static _typeCheckNumberArray(t, e, s) { return S(t, e, s) } static dateConversion(t, e, s) { return g(t, e, s) } static getFlattenDefaultOptions() { if (this._flattenDefaults) return this._flattenDefaults; let t = (e, s = []) => Array.isArray(e) ? [] : Object(e) === e ? Object.entries(e).flatMap(([e, i]) => t(i, [...s, e])) : s.join("."); return this._flattenDefaults = t(m), this._flattenDefaults } static _validateConflicts(t) { !t.display.sideBySide || t.display.components.clock && (t.display.components.hours || t.display.components.minutes || t.display.components.seconds) || r.errorMessages.conflictingConfiguration("Cannot use side by side mode without the clock components"), t.restrictions.minDate && t.restrictions.maxDate && (t.restrictions.minDate.isAfter(t.restrictions.maxDate) && r.errorMessages.conflictingConfiguration("minDate is after maxDate"), t.restrictions.maxDate.isBefore(t.restrictions.minDate) && r.errorMessages.conflictingConfiguration("maxDate is before minDate")) } } M.ignoreProperties = ["meta", "dayViewHeaderFormat", "container", "dateForms", "ordinal",], M.isValue = t => null != t; class L { constructor() { this._dates = [], this.optionsStore = l.locate(c), this.validation = l.locate(h), this._eventEmitters = l.locate(u) } get picked() { return this._dates } get lastPicked() { return this._dates[this.lastPickedIndex] } get lastPickedIndex() { return 0 === this._dates.length ? 0 : this._dates.length - 1 } formatInput(t) { let e = this.optionsStore.options.display.components; return t ? t.format({ year: e.calendar && e.year ? "numeric" : void 0, month: e.calendar && e.month ? "2-digit" : void 0, day: e.calendar && e.date ? "2-digit" : void 0, hour: e.clock && e.hours ? "2-digit" : void 0, minute: e.clock && e.minutes ? "2-digit" : void 0, second: e.clock && e.seconds ? "2-digit" : void 0, hourCycle: this.optionsStore.options.localization.hourCycle }) : "" } parseInput(t) { return M.dateConversion(t, "input", this.optionsStore.options.localization) } setFromInput(t, e) { if (!t) { this.setValue(void 0, e); return } let s = this.parseInput(t); s && (s.setLocale(this.optionsStore.options.localization.locale), this.setValue(s, e)) } add(t) { this._dates.push(t) } isPicked(t, e) { if (!e) return void 0 !== this._dates.find(e => e === t); let i = s(e), o = t.format(i); return void 0 !== this._dates.map(t => t.format(i)).find(t => t === o) } pickedIndex(t, e) { if (!e) return this._dates.indexOf(t); let i = s(e), o = t.format(i); return this._dates.map(t => t.format(i)).indexOf(o) } clear() { this.optionsStore.unset = !0, this._eventEmitters.triggerEvent.emit({ type: r.events.change, date: void 0, oldDate: this.lastPicked, isClear: !0, isValid: !0 }), this._dates = [] } static getStartEndYear(t, e) { let s = t / 10, i = Math.floor(e / t) * t; return [i, i + 9 * s, Math.floor(e / s) * s] } updateInput(t) { if (!this.optionsStore.input) return; let e = this.formatInput(t); this.optionsStore.options.multipleDates && (e = this._dates.map(t => this.formatInput(t)).join(this.optionsStore.options.multipleDatesSeparator)), this.optionsStore.input.value != e && (this.optionsStore.input.value = e) } setValue(t, e) { let s = void 0 === e, i = !t && s, o = this.optionsStore.unset ? null : this._dates[e]; if (!o && !this.optionsStore.unset && s && i && (o = this.lastPicked), t && o?.isSame(t)) { this.updateInput(t); return } if (!t) { !this.optionsStore.options.multipleDates || 1 === this._dates.length || i ? (this.optionsStore.unset = !0, this._dates = []) : this._dates.splice(e, 1), this.updateInput(), this._eventEmitters.triggerEvent.emit({ type: r.events.change, date: void 0, oldDate: o, isClear: i, isValid: !0 }), this._eventEmitters.updateDisplay.emit("all"); return } if (e = e || 0, t = t.clone, 1 !== this.optionsStore.options.stepping && (t.minutes = Math.round(t.minutes / this.optionsStore.options.stepping) * this.optionsStore.options.stepping, t.seconds = 0), this.validation.isValid(t)) { this._dates[e] = t, this._eventEmitters.updateViewDate.emit(t.clone), this.updateInput(t), this.optionsStore.unset = !1, this._eventEmitters.updateDisplay.emit("all"), this._eventEmitters.triggerEvent.emit({ type: r.events.change, date: t, oldDate: o, isClear: i, isValid: !0 }); return } this.optionsStore.options.keepInvalid && (this._dates[e] = t, this._eventEmitters.updateViewDate.emit(t.clone), this.updateInput(t), this._eventEmitters.triggerEvent.emit({ type: r.events.change, date: t, oldDate: o, isClear: i, isValid: !1 })), this._eventEmitters.triggerEvent.emit({ type: r.events.error, reason: r.errorMessages.failedToSetInvalidDate, date: t, oldDate: o }) } } (_ = U || (U = {})).next = "next", _.previous = "previous", _.changeCalendarView = "changeCalendarView", _.selectMonth = "selectMonth", _.selectYear = "selectYear", _.selectDecade = "selectDecade", _.selectDay = "selectDay", _.selectHour = "selectHour", _.selectMinute = "selectMinute", _.selectSecond = "selectSecond", _.incrementHours = "incrementHours", _.incrementMinutes = "incrementMinutes", _.incrementSeconds = "incrementSeconds", _.decrementHours = "decrementHours", _.decrementMinutes = "decrementMinutes", _.decrementSeconds = "decrementSeconds", _.toggleMeridiem = "toggleMeridiem", _.togglePicker = "togglePicker", _.showClock = "showClock", _.showHours = "showHours", _.showMinutes = "showMinutes", _.showSeconds = "showSeconds", _.clear = "clear", _.close = "close", _.today = "today"; var T, _, U, A = U; class V { static toggle(t) { t.classList.contains(r.css.show) ? this.hide(t) : this.show(t) } static showImmediately(t) { t.classList.remove(r.css.collapsing), t.classList.add(r.css.collapse, r.css.show), t.style.height = "" } static show(t) { if (t.classList.contains(r.css.collapsing) || t.classList.contains(r.css.show)) return; let e = () => { V.showImmediately(t) }; t.style.height = "0", t.classList.remove(r.css.collapse), t.classList.add(r.css.collapsing), setTimeout(e, this.getTransitionDurationFromElement(t)), t.style.height = `${t.scrollHeight}px` } static hideImmediately(t) { t && (t.classList.remove(r.css.collapsing, r.css.show), t.classList.add(r.css.collapse)) } static hide(t) { if (t.classList.contains(r.css.collapsing) || !t.classList.contains(r.css.show)) return; let e = () => { V.hideImmediately(t) }; t.style.height = `${t.getBoundingClientRect().height}px`, t.offsetHeight, t.classList.remove(r.css.collapse, r.css.show), t.classList.add(r.css.collapsing), t.style.height = "", setTimeout(e, this.getTransitionDurationFromElement(t)) } } V.getTransitionDurationFromElement = t => { if (!t) return 0; let { transitionDuration: e, transitionDelay: s } = window.getComputedStyle(t), i = Number.parseFloat(e), o = Number.parseFloat(s); return i || o ? (e = e.split(",")[0], s = s.split(",")[0], (Number.parseFloat(e) + Number.parseFloat(s)) * 1e3) : 0 }; class H { constructor() { this._isVisible = !1, this._documentClickEvent = t => { this.optionsStore.options.debug || window.debug || !this._isVisible || t.composedPath().includes(this.widget) || t.composedPath()?.includes(this.optionsStore.element) || this.hide() }, this._actionsClickEvent = t => { this._eventEmitters.action.emit({ e: t }) }, this.optionsStore = l.locate(c), this.validation = l.locate(h), this.dates = l.locate(L), this.dateDisplay = l.locate(class e { constructor() { this.optionsStore = l.locate(c), this.dates = l.locate(L), this.validation = l.locate(h) } getPicker() { let t = document.createElement("div"); if (t.classList.add(r.css.daysContainer), t.append(...this._daysOfTheWeek()), this.optionsStore.options.display.calendarWeeks) { let e = document.createElement("div"); e.classList.add(r.css.calendarWeeks, r.css.noHighlight), t.appendChild(e) } for (let s = 0; s < 42; s++) { if (0 !== s && s % 7 == 0 && this.optionsStore.options.display.calendarWeeks) { let i = document.createElement("div"); i.classList.add(r.css.calendarWeeks, r.css.noHighlight), t.appendChild(i) } let o = document.createElement("div"); o.setAttribute("data-action", A.selectDay), t.appendChild(o) } return t } _update(e, s) { let i = e.getElementsByClassName(r.css.daysContainer)[0]; if ("calendar" === this.optionsStore.currentView) { let [a, n, l] = i.parentElement.getElementsByClassName(r.css.calendarHeader)[0].getElementsByTagName("div"); n.setAttribute(r.css.daysContainer, this.optionsStore.viewDate.format(this.optionsStore.options.localization.dayViewHeaderFormat)), this.optionsStore.options.display.components.month ? n.classList.remove(r.css.disabled) : n.classList.add(r.css.disabled), this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(-1, t.Unit.month), t.Unit.month) ? a.classList.remove(r.css.disabled) : a.classList.add(r.css.disabled), this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(1, t.Unit.month), t.Unit.month) ? l.classList.remove(r.css.disabled) : l.classList.add(r.css.disabled) } let d = this.optionsStore.viewDate.clone.startOf(t.Unit.month).startOf("weekDay", this.optionsStore.options.localization.startOfTheWeek).manipulate(12, t.Unit.hours); i.querySelectorAll(`[data-action="${A.selectDay}"], .${r.css.calendarWeeks}`).forEach(e => { if (this.optionsStore.options.display.calendarWeeks && e.classList.contains(r.css.calendarWeeks)) { if ("#" === e.innerText) return; e.innerText = `${d.week}`; return } let i = []; i.push(r.css.day), d.isBefore(this.optionsStore.viewDate, t.Unit.month) && i.push(r.css.old), d.isAfter(this.optionsStore.viewDate, t.Unit.month) && i.push(r.css.new), !this.optionsStore.unset && this.dates.isPicked(d, t.Unit.date) && i.push(r.css.active), this.validation.isValid(d, t.Unit.date) || i.push(r.css.disabled), d.isSame(new o, t.Unit.date) && i.push(r.css.today), (0 === d.weekDay || 6 === d.weekDay) && i.push(r.css.weekend), s(t.Unit.date, d, i, e), e.classList.remove(...e.classList), e.classList.add(...i), e.setAttribute("data-value", `${d.year}-${d.monthFormatted}-${d.dateFormatted}`), e.setAttribute("data-day", `${d.date}`), e.innerText = d.format({ day: "numeric" }), d.manipulate(1, t.Unit.date) }) } _daysOfTheWeek() { let e = this.optionsStore.viewDate.clone.startOf("weekDay", this.optionsStore.options.localization.startOfTheWeek).startOf(t.Unit.date), s = []; if (document.createElement("div"), this.optionsStore.options.display.calendarWeeks) { let i = document.createElement("div"); i.classList.add(r.css.calendarWeeks, r.css.noHighlight), i.innerText = "#", s.push(i) } for (let o = 0; o < 7; o++) { let a = document.createElement("div"); a.classList.add(r.css.dayOfTheWeek, r.css.noHighlight), a.innerText = e.format({ weekday: "short" }), e.manipulate(1, t.Unit.date), s.push(a) } return s } }), this.monthDisplay = l.locate(class e { constructor() { this.optionsStore = l.locate(c), this.dates = l.locate(L), this.validation = l.locate(h) } getPicker() { let t = document.createElement("div"); t.classList.add(r.css.monthsContainer); for (let e = 0; e < 12; e++) { let s = document.createElement("div"); s.setAttribute("data-action", A.selectMonth), t.appendChild(s) } return t } _update(e, s) { let i = e.getElementsByClassName(r.css.monthsContainer)[0]; if ("months" === this.optionsStore.currentView) { let [o, a, n] = i.parentElement.getElementsByClassName(r.css.calendarHeader)[0].getElementsByTagName("div"); a.setAttribute(r.css.monthsContainer, this.optionsStore.viewDate.format({ year: "numeric" })), this.optionsStore.options.display.components.year ? a.classList.remove(r.css.disabled) : a.classList.add(r.css.disabled), this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(-1, t.Unit.year), t.Unit.year) ? o.classList.remove(r.css.disabled) : o.classList.add(r.css.disabled), this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(1, t.Unit.year), t.Unit.year) ? n.classList.remove(r.css.disabled) : n.classList.add(r.css.disabled) } let l = this.optionsStore.viewDate.clone.startOf(t.Unit.year); i.querySelectorAll(`[data-action="${A.selectMonth}"]`).forEach((e, i) => { let o = []; o.push(r.css.month), !this.optionsStore.unset && this.dates.isPicked(l, t.Unit.month) && o.push(r.css.active), this.validation.isValid(l, t.Unit.month) || o.push(r.css.disabled), s(t.Unit.month, l, o, e), e.classList.remove(...e.classList), e.classList.add(...o), e.setAttribute("data-value", `${i}`), e.innerText = `${l.format({ month: "short" })}`, l.manipulate(1, t.Unit.month) }) } }), this.yearDisplay = l.locate(class e { constructor() { this.optionsStore = l.locate(c), this.dates = l.locate(L), this.validation = l.locate(h) } getPicker() { let t = document.createElement("div"); t.classList.add(r.css.yearsContainer); for (let e = 0; e < 12; e++) { let s = document.createElement("div"); s.setAttribute("data-action", A.selectYear), t.appendChild(s) } return t } _update(e, s) { this._startYear = this.optionsStore.viewDate.clone.manipulate(-1, t.Unit.year), this._endYear = this.optionsStore.viewDate.clone.manipulate(10, t.Unit.year); let i = e.getElementsByClassName(r.css.yearsContainer)[0]; if ("years" === this.optionsStore.currentView) { let [o, a, n] = i.parentElement.getElementsByClassName(r.css.calendarHeader)[0].getElementsByTagName("div"); a.setAttribute(r.css.yearsContainer, `${this._startYear.format({ year: "numeric" })}-${this._endYear.format({ year: "numeric" })}`), this.optionsStore.options.display.components.decades ? a.classList.remove(r.css.disabled) : a.classList.add(r.css.disabled), this.validation.isValid(this._startYear, t.Unit.year) ? o.classList.remove(r.css.disabled) : o.classList.add(r.css.disabled), this.validation.isValid(this._endYear, t.Unit.year) ? n.classList.remove(r.css.disabled) : n.classList.add(r.css.disabled) } let l = this.optionsStore.viewDate.clone.startOf(t.Unit.year).manipulate(-1, t.Unit.year); i.querySelectorAll(`[data-action="${A.selectYear}"]`).forEach(e => { let i = []; i.push(r.css.year), !this.optionsStore.unset && this.dates.isPicked(l, t.Unit.year) && i.push(r.css.active), this.validation.isValid(l, t.Unit.year) || i.push(r.css.disabled), s(t.Unit.year, l, i, e), e.classList.remove(...e.classList), e.classList.add(...i), e.setAttribute("data-value", `${l.year}`), e.innerText = l.format({ year: "numeric" }), l.manipulate(1, t.Unit.year) }) } }), this.decadeDisplay = l.locate(class e { constructor() { this.optionsStore = l.locate(c), this.dates = l.locate(L), this.validation = l.locate(h) } getPicker() { let t = document.createElement("div"); t.classList.add(r.css.decadesContainer); for (let e = 0; e < 12; e++) { let s = document.createElement("div"); s.setAttribute("data-action", A.selectDecade), t.appendChild(s) } return t } _update(e, s) { let [i, o] = L.getStartEndYear(100, this.optionsStore.viewDate.year); this._startDecade = this.optionsStore.viewDate.clone.startOf(t.Unit.year), this._startDecade.year = i, this._endDecade = this.optionsStore.viewDate.clone.startOf(t.Unit.year), this._endDecade.year = o; let a = e.getElementsByClassName(r.css.decadesContainer)[0], [n, l, d] = a.parentElement.getElementsByClassName(r.css.calendarHeader)[0].getElementsByTagName("div"); "decades" === this.optionsStore.currentView && (l.setAttribute(r.css.decadesContainer, `${this._startDecade.format({ year: "numeric" })}-${this._endDecade.format({ year: "numeric" })}`), this.validation.isValid(this._startDecade, t.Unit.year) ? n.classList.remove(r.css.disabled) : n.classList.add(r.css.disabled), this.validation.isValid(this._endDecade, t.Unit.year) ? d.classList.remove(r.css.disabled) : d.classList.add(r.css.disabled)); let c = this.dates.picked.map(t => t.year); a.querySelectorAll(`[data-action="${A.selectDecade}"]`).forEach((e, i) => { if (0 === i) { if (e.classList.add(r.css.old), this._startDecade.year - 10 < 0) { e.textContent = " ", n.classList.add(r.css.disabled), e.classList.add(r.css.disabled), e.setAttribute("data-value", ""); return } e.innerText = this._startDecade.clone.manipulate(-10, t.Unit.year).format({ year: "numeric" }), e.setAttribute("data-value", `${this._startDecade.year}`); return } let o = []; o.push(r.css.decade); let a = this._startDecade.year, l = this._startDecade.year + 9; !this.optionsStore.unset && c.filter(t => t >= a && t <= l).length > 0 && o.push(r.css.active), s("decade", this._startDecade, o, e), e.classList.remove(...e.classList), e.classList.add(...o), e.setAttribute("data-value", `${this._startDecade.year}`), e.innerText = `${this._startDecade.format({ year: "numeric" })}`, this._startDecade.manipulate(10, t.Unit.year) }) } }), this.timeDisplay = l.locate(class e { constructor() { this._gridColumns = "", this.optionsStore = l.locate(c), this.dates = l.locate(L), this.validation = l.locate(h) } getPicker(t) { let e = document.createElement("div"); return e.classList.add(r.css.clockContainer), e.append(...this._grid(t)), e } _update(e) { let s = e.getElementsByClassName(r.css.clockContainer)[0], i = (this.dates.lastPicked || this.optionsStore.viewDate).clone; if (s.querySelectorAll(".disabled").forEach(t => t.classList.remove(r.css.disabled)), this.optionsStore.options.display.components.hours && (this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(1, t.Unit.hours), t.Unit.hours) || s.querySelector(`[data-action=${A.incrementHours}]`).classList.add(r.css.disabled), this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(-1, t.Unit.hours), t.Unit.hours) || s.querySelector(`[data-action=${A.decrementHours}]`).classList.add(r.css.disabled), s.querySelector(`[data-time-component=${t.Unit.hours}]`).innerText = i.getHoursFormatted(this.optionsStore.options.localization.hourCycle)), this.optionsStore.options.display.components.minutes && (this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(1, t.Unit.minutes), t.Unit.minutes) || s.querySelector(`[data-action=${A.incrementMinutes}]`).classList.add(r.css.disabled), this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(-1, t.Unit.minutes), t.Unit.minutes) || s.querySelector(`[data-action=${A.decrementMinutes}]`).classList.add(r.css.disabled), s.querySelector(`[data-time-component=${t.Unit.minutes}]`).innerText = i.minutesFormatted), this.optionsStore.options.display.components.seconds && (this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(1, t.Unit.seconds), t.Unit.seconds) || s.querySelector(`[data-action=${A.incrementSeconds}]`).classList.add(r.css.disabled), this.validation.isValid(this.optionsStore.viewDate.clone.manipulate(-1, t.Unit.seconds), t.Unit.seconds) || s.querySelector(`[data-action=${A.decrementSeconds}]`).classList.add(r.css.disabled), s.querySelector(`[data-time-component=${t.Unit.seconds}]`).innerText = i.secondsFormatted), this.optionsStore.isTwelveHour) { let o = s.querySelector(`[data-action=${A.toggleMeridiem}]`); o.innerText = i.meridiem(), this.validation.isValid(i.clone.manipulate(i.hours >= 12 ? -12 : 12, t.Unit.hours)) ? o.classList.remove(r.css.disabled) : o.classList.add(r.css.disabled) } s.style.gridTemplateAreas = `"${this._gridColumns}"` } _grid(e) { this._gridColumns = ""; let s = [], i = [], o = [], a = document.createElement("div"), n = e(this.optionsStore.options.display.icons.up), l = e(this.optionsStore.options.display.icons.down); a.classList.add(r.css.separator, r.css.noHighlight); let d = a.cloneNode(!0); d.innerHTML = ":"; let c = (t = !1) => t ? d.cloneNode(!0) : a.cloneNode(!0); if (this.optionsStore.options.display.components.hours) { let h = document.createElement("div"); h.setAttribute("title", this.optionsStore.options.localization.incrementHour), h.setAttribute("data-action", A.incrementHours), h.appendChild(n.cloneNode(!0)), s.push(h), (h = document.createElement("div")).setAttribute("title", this.optionsStore.options.localization.pickHour), h.setAttribute("data-action", A.showHours), h.setAttribute("data-time-component", t.Unit.hours), i.push(h), (h = document.createElement("div")).setAttribute("title", this.optionsStore.options.localization.decrementHour), h.setAttribute("data-action", A.decrementHours), h.appendChild(l.cloneNode(!0)), o.push(h), this._gridColumns += "a" } if (this.optionsStore.options.display.components.minutes) { this._gridColumns += " a", this.optionsStore.options.display.components.hours && (s.push(c()), i.push(c(!0)), o.push(c()), this._gridColumns += " a"); let p = document.createElement("div"); p.setAttribute("title", this.optionsStore.options.localization.incrementMinute), p.setAttribute("data-action", A.incrementMinutes), p.appendChild(n.cloneNode(!0)), s.push(p), (p = document.createElement("div")).setAttribute("title", this.optionsStore.options.localization.pickMinute), p.setAttribute("data-action", A.showMinutes), p.setAttribute("data-time-component", t.Unit.minutes), i.push(p), (p = document.createElement("div")).setAttribute("title", this.optionsStore.options.localization.decrementMinute), p.setAttribute("data-action", A.decrementMinutes), p.appendChild(l.cloneNode(!0)), o.push(p) } if (this.optionsStore.options.display.components.seconds) { this._gridColumns += " a", this.optionsStore.options.display.components.minutes && (s.push(c()), i.push(c(!0)), o.push(c()), this._gridColumns += " a"); let u = document.createElement("div"); u.setAttribute("title", this.optionsStore.options.localization.incrementSecond), u.setAttribute("data-action", A.incrementSeconds), u.appendChild(n.cloneNode(!0)), s.push(u), (u = document.createElement("div")).setAttribute("title", this.optionsStore.options.localization.pickSecond), u.setAttribute("data-action", A.showSeconds), u.setAttribute("data-time-component", t.Unit.seconds), i.push(u), (u = document.createElement("div")).setAttribute("title", this.optionsStore.options.localization.decrementSecond), u.setAttribute("data-action", A.decrementSeconds), u.appendChild(l.cloneNode(!0)), o.push(u) } if (this.optionsStore.isTwelveHour) { this._gridColumns += " a"; let m = c(); s.push(m); let y = document.createElement("button"); y.setAttribute("title", this.optionsStore.options.localization.toggleMeridiem), y.setAttribute("data-action", A.toggleMeridiem), y.setAttribute("tabindex", "-1"), r.css.toggleMeridiem.includes(",") ? y.classList.add(...r.css.toggleMeridiem.split(",")) : y.classList.add(r.css.toggleMeridiem), (m = document.createElement("div")).classList.add(r.css.noHighlight), m.appendChild(y), i.push(m), m = c(), o.push(m) } return this._gridColumns = this._gridColumns.trim(), [...s, ...i, ...o] } }), this.hourDisplay = l.locate(class e { constructor() { this.optionsStore = l.locate(c), this.validation = l.locate(h) } getPicker() { let t = document.createElement("div"); t.classList.add(r.css.hourContainer); for (let e = 0; e < (this.optionsStore.isTwelveHour ? 12 : 24); e++) { let s = document.createElement("div"); s.setAttribute("data-action", A.selectHour), t.appendChild(s) } return t } _update(e, s) { let i = e.getElementsByClassName(r.css.hourContainer)[0], o = this.optionsStore.viewDate.clone.startOf(t.Unit.date); i.querySelectorAll(`[data-action="${A.selectHour}"]`).forEach(e => { let i = []; i.push(r.css.hour), this.validation.isValid(o, t.Unit.hours) || i.push(r.css.disabled), s(t.Unit.hours, o, i, e), e.classList.remove(...e.classList), e.classList.add(...i), e.setAttribute("data-value", `${o.hours}`), e.innerText = o.getHoursFormatted(this.optionsStore.options.localization.hourCycle), o.manipulate(1, t.Unit.hours) }) } }), this.minuteDisplay = l.locate(class e { constructor() { this.optionsStore = l.locate(c), this.validation = l.locate(h) } getPicker() { let t = document.createElement("div"); t.classList.add(r.css.minuteContainer); let e = 1 === this.optionsStore.options.stepping ? 5 : this.optionsStore.options.stepping; for (let s = 0; s < 60 / e; s++) { let i = document.createElement("div"); i.setAttribute("data-action", A.selectMinute), t.appendChild(i) } return t } _update(e, s) { let i = e.getElementsByClassName(r.css.minuteContainer)[0], o = this.optionsStore.viewDate.clone.startOf(t.Unit.hours), a = 1 === this.optionsStore.options.stepping ? 5 : this.optionsStore.options.stepping; i.querySelectorAll(`[data-action="${A.selectMinute}"]`).forEach(e => { let i = []; i.push(r.css.minute), this.validation.isValid(o, t.Unit.minutes) || i.push(r.css.disabled), s(t.Unit.minutes, o, i, e), e.classList.remove(...e.classList), e.classList.add(...i), e.setAttribute("data-value", `${o.minutes}`), e.innerText = o.minutesFormatted, o.manipulate(a, t.Unit.minutes) }) } }), this.secondDisplay = l.locate(class e { constructor() { this.optionsStore = l.locate(c), this.validation = l.locate(h) } getPicker() { let t = document.createElement("div"); t.classList.add(r.css.secondContainer); for (let e = 0; e < 12; e++) { let s = document.createElement("div"); s.setAttribute("data-action", A.selectSecond), t.appendChild(s) } return t } _update(e, s) { let i = e.getElementsByClassName(r.css.secondContainer)[0], o = this.optionsStore.viewDate.clone.startOf(t.Unit.minutes); i.querySelectorAll(`[data-action="${A.selectSecond}"]`).forEach(e => { let i = []; i.push(r.css.second), this.validation.isValid(o, t.Unit.seconds) || i.push(r.css.disabled), s(t.Unit.seconds, o, i, e), e.classList.remove(...e.classList), e.classList.add(...i), e.setAttribute("data-value", `${o.seconds}`), e.innerText = o.secondsFormatted, o.manipulate(5, t.Unit.seconds) }) } }), this._eventEmitters = l.locate(u), this._widget = void 0, this._eventEmitters.updateDisplay.subscribe(t => { this._update(t) }) } get widget() { return this._widget } get isVisible() { return this._isVisible } _update(e) { if (this.widget) switch (e) { case t.Unit.seconds: this.secondDisplay._update(this.widget, this.paint); break; case t.Unit.minutes: this.minuteDisplay._update(this.widget, this.paint); break; case t.Unit.hours: this.hourDisplay._update(this.widget, this.paint); break; case t.Unit.date: this.dateDisplay._update(this.widget, this.paint); break; case t.Unit.month: this.monthDisplay._update(this.widget, this.paint); break; case t.Unit.year: this.yearDisplay._update(this.widget, this.paint); break; case "clock": if (!this._hasTime) break; this.timeDisplay._update(this.widget), this._update(t.Unit.hours), this._update(t.Unit.minutes), this._update(t.Unit.seconds); break; case "calendar": this._update(t.Unit.date), this._update(t.Unit.year), this._update(t.Unit.month), this.decadeDisplay._update(this.widget, this.paint), this._updateCalendarHeader(); break; case "all": this._hasTime && this._update("clock"), this._hasDate && this._update("calendar") } } paint(t, e, s, i) { } show() { if (void 0 == this.widget) { if (0 == this.dates.picked.length) { if (this.optionsStore.options.useCurrent && !this.optionsStore.options.defaultDate) { let e = new o().setLocale(this.optionsStore.options.localization.locale); if (!this.optionsStore.options.keepInvalid) { let s = 0, i = 1; for (this.optionsStore.options.restrictions.maxDate?.isBefore(e) && (i = -1); !this.validation.isValid(e) && (e.manipulate(i, t.Unit.date), !(s > 31));)s++ } this.dates.setValue(e) } this.optionsStore.options.defaultDate && this.dates.setValue(this.optionsStore.options.defaultDate) } this._buildWidget(), this._updateTheme(); let a = this._hasTime && !this._hasDate; (a && (this.optionsStore.currentView = "clock", this._eventEmitters.action.emit({ e: null, action: A.showClock })), this.optionsStore.currentCalendarViewMode || (this.optionsStore.currentCalendarViewMode = this.optionsStore.minimumCalendarViewMode), a || "clock" === this.optionsStore.options.display.viewMode || (this._hasTime && (this.optionsStore.options.display.sideBySide ? V.show(this.widget.querySelector(`div.${r.css.timeContainer}`)) : V.hideImmediately(this.widget.querySelector(`div.${r.css.timeContainer}`))), V.show(this.widget.querySelector(`div.${r.css.dateContainer}`))), this._hasDate && this._showMode(), this.optionsStore.options.display.inline) ? this.optionsStore.element.appendChild(this.widget) : ((this.optionsStore.options?.container || document.body).appendChild(this.widget), this.createPopup(this.optionsStore.element, this.widget, { modifiers: [{ name: "eventListeners", enabled: !0 }], placement: "rtl" === document.documentElement.dir ? "bottom-end" : "bottom-start" }).then()), "clock" == this.optionsStore.options.display.viewMode && this._eventEmitters.action.emit({ e: null, action: A.showClock }), this.widget.querySelectorAll("[data-action]").forEach(t => { t.addEventListener("click", this._actionsClickEvent), t.addEventListener("touchend", this._actionsClickEvent) }), this._hasTime && this.optionsStore.options.display.sideBySide && (this.timeDisplay._update(this.widget), this.widget.getElementsByClassName(r.css.clockContainer)[0].style.display = "grid") } this.widget.classList.add(r.css.show), this.optionsStore.options.display.inline || (this.updatePopup(), document.addEventListener("click", this._documentClickEvent)), this._eventEmitters.triggerEvent.emit({ type: r.events.show }), this._isVisible = !0 } async createPopup(t, e, s) { let i; if (window?.Popper) i = window?.Popper?.createPopper; else { let { createPopper: o } = await import("@popperjs/core"); i = o } i && (this._popperInstance = i(t, e, s)) } updatePopup() { this._popperInstance?.update() } _showMode(t) { if (!this.widget) return; if (t) { let e = Math.max(this.optionsStore.minimumCalendarViewMode, Math.min(3, this.optionsStore.currentCalendarViewMode + t)); if (this.optionsStore.currentCalendarViewMode == e) return; this.optionsStore.currentCalendarViewMode = e } this.widget.querySelectorAll(`.${r.css.dateContainer} > div:not(.${r.css.calendarHeader}), .${r.css.timeContainer} > div:not(.${r.css.clockContainer})`).forEach(t => t.style.display = "none"); let s = d[this.optionsStore.currentCalendarViewMode], i = this.widget.querySelector(`.${s.className}`); switch (s.className) { case r.css.decadesContainer: this.decadeDisplay._update(this.widget, this.paint); break; case r.css.yearsContainer: this.yearDisplay._update(this.widget, this.paint); break; case r.css.monthsContainer: this.monthDisplay._update(this.widget, this.paint); break; case r.css.daysContainer: this.dateDisplay._update(this.widget, this.paint) }i.style.display = "grid", this.optionsStore.options.display.sideBySide && (this.widget.querySelectorAll(`.${r.css.clockContainer}`)[0].style.display = "grid"), this._updateCalendarHeader(), this._eventEmitters.viewUpdate.emit() } _updateTheme(t) { if (this.widget) { if (t) { if (this.optionsStore.options.display.theme === t) return; this.optionsStore.options.display.theme = t } this.widget.classList.remove("light", "dark"), this.widget.classList.add(this._getThemeClass()), "auto" === this.optionsStore.options.display.theme ? window.matchMedia(r.css.isDarkPreferredQuery).addEventListener("change", () => this._updateTheme()) : window.matchMedia(r.css.isDarkPreferredQuery).removeEventListener("change", () => this._updateTheme()) } } _getThemeClass() { let t = this.optionsStore.options.display.theme || "auto", e = window.matchMedia && window.matchMedia(r.css.isDarkPreferredQuery).matches; switch (t) { case "light": return r.css.lightTheme; case "dark": return r.css.darkTheme; case "auto": return e ? r.css.darkTheme : r.css.lightTheme } } _updateCalendarHeader() { if (!this._hasDate) return; let t = [...this.widget.querySelector(`.${r.css.dateContainer} div[style*="display: grid"]`).classList,].find(t => t.startsWith(r.css.dateContainer)), [e, s, i] = this.widget.getElementsByClassName(r.css.calendarHeader)[0].getElementsByTagName("div"); switch (t) { case r.css.decadesContainer: e.setAttribute("title", this.optionsStore.options.localization.previousCentury), s.setAttribute("title", ""), i.setAttribute("title", this.optionsStore.options.localization.nextCentury); break; case r.css.yearsContainer: e.setAttribute("title", this.optionsStore.options.localization.previousDecade), s.setAttribute("title", this.optionsStore.options.localization.selectDecade), i.setAttribute("title", this.optionsStore.options.localization.nextDecade); break; case r.css.monthsContainer: e.setAttribute("title", this.optionsStore.options.localization.previousYear), s.setAttribute("title", this.optionsStore.options.localization.selectYear), i.setAttribute("title", this.optionsStore.options.localization.nextYear); break; case r.css.daysContainer: e.setAttribute("title", this.optionsStore.options.localization.previousMonth), s.setAttribute("title", this.optionsStore.options.localization.selectMonth), i.setAttribute("title", this.optionsStore.options.localization.nextMonth), s.setAttribute(t, this.optionsStore.viewDate.format(this.optionsStore.options.localization.dayViewHeaderFormat)) }s.innerText = s.getAttribute(t) } hide() { this.widget && this._isVisible && (this.widget.classList.remove(r.css.show), this._isVisible && (this._eventEmitters.triggerEvent.emit({ type: r.events.hide, date: this.optionsStore.unset ? null : this.dates.lastPicked ? this.dates.lastPicked.clone : void 0 }), this._isVisible = !1), document.removeEventListener("click", this._documentClickEvent)) } toggle() { return this._isVisible ? this.hide() : this.show() } _dispose() { document.removeEventListener("click", this._documentClickEvent), this.widget && (this.widget.querySelectorAll("[data-action]").forEach(t => t.removeEventListener("click", this._actionsClickEvent)), this.widget.parentNode.removeChild(this.widget), this._widget = void 0) } _buildWidget() { let t = document.createElement("div"); t.classList.add(r.css.widget); let e = document.createElement("div"); e.classList.add(r.css.dateContainer), e.append(this.getHeadTemplate(), this.decadeDisplay.getPicker(), this.yearDisplay.getPicker(), this.monthDisplay.getPicker(), this.dateDisplay.getPicker()); let s = document.createElement("div"); s.classList.add(r.css.timeContainer), s.appendChild(this.timeDisplay.getPicker(this._iconTag.bind(this))), s.appendChild(this.hourDisplay.getPicker()), s.appendChild(this.minuteDisplay.getPicker()), s.appendChild(this.secondDisplay.getPicker()); let i = document.createElement("div"); if (i.classList.add(r.css.toolbar), i.append(...this.getToolbarElements()), this.optionsStore.options.display.inline && t.classList.add(r.css.inline), this.optionsStore.options.display.calendarWeeks && t.classList.add("calendarWeeks"), this.optionsStore.options.display.sideBySide && this._hasDate && this._hasTime) { t.classList.add(r.css.sideBySide), "top" === this.optionsStore.options.display.toolbarPlacement && t.appendChild(i); let o = document.createElement("div"); o.classList.add("td-row"), e.classList.add("td-half"), s.classList.add("td-half"), o.appendChild(e), o.appendChild(s), t.appendChild(o), "bottom" === this.optionsStore.options.display.toolbarPlacement && t.appendChild(i), this._widget = t; return } "top" === this.optionsStore.options.display.toolbarPlacement && t.appendChild(i), this._hasDate && (this._hasTime && (e.classList.add(r.css.collapse), "clock" !== this.optionsStore.options.display.viewMode && e.classList.add(r.css.show)), t.appendChild(e)), this._hasTime && (this._hasDate && (s.classList.add(r.css.collapse), "clock" === this.optionsStore.options.display.viewMode && s.classList.add(r.css.show)), t.appendChild(s)), "bottom" === this.optionsStore.options.display.toolbarPlacement && t.appendChild(i); let a = document.createElement("div"); a.classList.add("arrow"), a.setAttribute("data-popper-arrow", ""), t.appendChild(a), this._widget = t } get _hasTime() { return this.optionsStore.options.display.components.clock && (this.optionsStore.options.display.components.hours || this.optionsStore.options.display.components.minutes || this.optionsStore.options.display.components.seconds) } get _hasDate() { return this.optionsStore.options.display.components.calendar && (this.optionsStore.options.display.components.year || this.optionsStore.options.display.components.month || this.optionsStore.options.display.components.date) } getToolbarElements() { let t = []; if (this.optionsStore.options.display.buttons.today) { let e = document.createElement("div"); e.setAttribute("data-action", A.today), e.setAttribute("title", this.optionsStore.options.localization.today), e.appendChild(this._iconTag(this.optionsStore.options.display.icons.today)), t.push(e) } if (!this.optionsStore.options.display.sideBySide && this._hasDate && this._hasTime) { let s, i; "clock" === this.optionsStore.options.display.viewMode ? (s = this.optionsStore.options.localization.selectDate, i = this.optionsStore.options.display.icons.date) : (s = this.optionsStore.options.localization.selectTime, i = this.optionsStore.options.display.icons.time); let o = document.createElement("div"); o.setAttribute("data-action", A.togglePicker), o.setAttribute("title", s), o.appendChild(this._iconTag(i)), t.push(o) } if (this.optionsStore.options.display.buttons.clear) { let a = document.createElement("div"); a.setAttribute("data-action", A.clear), a.setAttribute("title", this.optionsStore.options.localization.clear), a.appendChild(this._iconTag(this.optionsStore.options.display.icons.clear)), t.push(a) } if (this.optionsStore.options.display.buttons.close) { let n = document.createElement("div"); n.setAttribute("data-action", A.close), n.setAttribute("title", this.optionsStore.options.localization.close), n.appendChild(this._iconTag(this.optionsStore.options.display.icons.close)), t.push(n) } return t } getHeadTemplate() { let t = document.createElement("div"); t.classList.add(r.css.calendarHeader); let e = document.createElement("div"); e.classList.add(r.css.previous), e.setAttribute("data-action", A.previous), e.appendChild(this._iconTag(this.optionsStore.options.display.icons.previous)); let s = document.createElement("div"); s.classList.add(r.css.switch), s.setAttribute("data-action", A.changeCalendarView); let i = document.createElement("div"); return i.classList.add(r.css.next), i.setAttribute("data-action", A.next), i.appendChild(this._iconTag(this.optionsStore.options.display.icons.next)), t.append(e, s, i), t } _iconTag(t) { if ("sprites" === this.optionsStore.options.display.icons.type) { let e = document.createElementNS("http://www.w3.org/2000/svg", "svg"), s = document.createElementNS("http://www.w3.org/2000/svg", "use"); return s.setAttribute("xlink:href", t), s.setAttribute("href", t), e.appendChild(s), e } let i = document.createElement("i"); return i.classList.add(...t.split(" ")), i } _rebuild() { let t = this._isVisible; this._dispose(), t && this.show() } } class O { constructor(e, s = {}) { this._subscribers = {}, this._isDisabled = !1, this._inputChangeEvent = t => { if (t?.detail) return; let e = () => { this.dates.lastPicked && (this.optionsStore.viewDate = this.dates.lastPicked.clone) }, s = this.optionsStore.input.value; if (this.optionsStore.options.multipleDates) try { let i = s.split(this.optionsStore.options.multipleDatesSeparator); for (let o = 0; o < i.length; o++)this.dates.setFromInput(i[o], o); e() } catch { console.warn("TD: Something went wrong trying to set the multipleDates values from the input field.") } else this.dates.setFromInput(s, 0), e() }, this._toggleClickEvent = () => { this.optionsStore.element?.disabled || this.optionsStore.input?.disabled || this.toggle() }, l = new class t { constructor() { this.cache = new Map } locate(t) { let e = this.cache.get(t); if (e) return e; let s = new t; return this.cache.set(t, s), s } }, this._eventEmitters = l.locate(u), this.optionsStore = l.locate(c), this.display = l.locate(H), this.dates = l.locate(L), this.actions = l.locate(class e { constructor() { this.optionsStore = l.locate(c), this.dates = l.locate(L), this.validation = l.locate(h), this.display = l.locate(H), this._eventEmitters = l.locate(u), this._eventEmitters.action.subscribe(t => { this.do(t.e, t.action) }) } do(e, s) { let i = e?.currentTarget; if (i?.classList?.contains(r.css.disabled)) return !1; s = s || i?.dataset?.action; let a = (this.dates.lastPicked || this.optionsStore.viewDate).clone; switch (s) { case A.next: case A.previous: this.handleNextPrevious(s); break; case A.changeCalendarView: this.display._showMode(1), this.display._updateCalendarHeader(); break; case A.selectMonth: case A.selectYear: case A.selectDecade: this.handleSelectCalendarMode(s, i); break; case A.selectDay: this.handleSelectDay(i); break; case A.selectHour: { let n = +i.dataset.value; a.hours >= 12 && this.optionsStore.isTwelveHour && (n += 12), a.hours = n, this.dates.setValue(a, this.dates.lastPickedIndex), this.hideOrClock(e); break } case A.selectMinute: a.minutes = +i.dataset.value, this.dates.setValue(a, this.dates.lastPickedIndex), this.hideOrClock(e); break; case A.selectSecond: a.seconds = +i.dataset.value, this.dates.setValue(a, this.dates.lastPickedIndex), this.hideOrClock(e); break; case A.incrementHours: this.manipulateAndSet(a, t.Unit.hours); break; case A.incrementMinutes: this.manipulateAndSet(a, t.Unit.minutes, this.optionsStore.options.stepping); break; case A.incrementSeconds: this.manipulateAndSet(a, t.Unit.seconds); break; case A.decrementHours: this.manipulateAndSet(a, t.Unit.hours, -1); break; case A.decrementMinutes: this.manipulateAndSet(a, t.Unit.minutes, -1 * this.optionsStore.options.stepping); break; case A.decrementSeconds: this.manipulateAndSet(a, t.Unit.seconds, -1); break; case A.toggleMeridiem: this.manipulateAndSet(a, t.Unit.hours, this.dates.lastPicked.hours >= 12 ? -12 : 12); break; case A.togglePicker: this.handleToggle(i); break; case A.showClock: case A.showHours: case A.showMinutes: case A.showSeconds: this.optionsStore.options.display.sideBySide || "clock" === this.optionsStore.currentView || (V.hideImmediately(this.display.widget.querySelector(`div.${r.css.dateContainer}`)), V.showImmediately(this.display.widget.querySelector(`div.${r.css.timeContainer}`))), this.handleShowClockContainers(s); break; case A.clear: this.dates.setValue(null), this.display._updateCalendarHeader(); break; case A.close: this.display.hide(); break; case A.today: { let l = new o().setLocale(this.optionsStore.options.localization.locale); this._eventEmitters.updateViewDate.emit(l), this.validation.isValid(l, t.Unit.date) && this.dates.setValue(l, this.dates.lastPickedIndex) } } } handleShowClockContainers(e) { if (!this.display._hasTime) { r.errorMessages.throwError("Cannot show clock containers when time is disabled."); return } this.optionsStore.currentView = "clock", this.display.widget.querySelectorAll(`.${r.css.timeContainer} > div`).forEach(t => t.style.display = "none"); let s = ""; switch (e) { case A.showClock: s = r.css.clockContainer, this.display._update("clock"); break; case A.showHours: s = r.css.hourContainer, this.display._update(t.Unit.hours); break; case A.showMinutes: s = r.css.minuteContainer, this.display._update(t.Unit.minutes); break; case A.showSeconds: s = r.css.secondContainer, this.display._update(t.Unit.seconds) }this.display.widget.getElementsByClassName(s)[0].style.display = "grid" } handleNextPrevious(t) { let { unit: e, step: s } = d[this.optionsStore.currentCalendarViewMode]; t === A.next ? this.optionsStore.viewDate.manipulate(s, e) : this.optionsStore.viewDate.manipulate(-1 * s, e), this._eventEmitters.viewUpdate.emit(), this.display._showMode() } hideOrClock(t) { this.optionsStore.isTwelveHour || this.optionsStore.options.display.components.minutes || this.optionsStore.options.display.keepOpen || this.optionsStore.options.display.inline ? this.do(t, A.showClock) : this.display.hide() } manipulateAndSet(t, e, s = 1) { let i = t.manipulate(s, e); this.validation.isValid(i, e) && this.dates.setValue(i, this.dates.lastPickedIndex) } handleSelectCalendarMode(t, e) { let s = +e.dataset.value; switch (t) { case A.selectMonth: this.optionsStore.viewDate.month = s; break; case A.selectYear: case A.selectDecade: this.optionsStore.viewDate.year = s }this.optionsStore.currentCalendarViewMode === this.optionsStore.minimumCalendarViewMode ? (this.dates.setValue(this.optionsStore.viewDate, this.dates.lastPickedIndex), this.optionsStore.options.display.inline || this.display.hide()) : this.display._showMode(-1) } handleToggle(t) { t.getAttribute("title") === this.optionsStore.options.localization.selectDate ? (t.setAttribute("title", this.optionsStore.options.localization.selectTime), t.innerHTML = this.display._iconTag(this.optionsStore.options.display.icons.time).outerHTML, this.display._updateCalendarHeader(), this.optionsStore.refreshCurrentView()) : (t.setAttribute("title", this.optionsStore.options.localization.selectDate), t.innerHTML = this.display._iconTag(this.optionsStore.options.display.icons.date).outerHTML, this.display._hasTime && (this.handleShowClockContainers(A.showClock), this.display._update("clock"))), this.display.widget.querySelectorAll(`.${r.css.dateContainer}, .${r.css.timeContainer}`).forEach(t => V.toggle(t)), this._eventEmitters.viewUpdate.emit() } handleSelectDay(e) { let s = this.optionsStore.viewDate.clone; e.classList.contains(r.css.old) && s.manipulate(-1, t.Unit.month), e.classList.contains(r.css.new) && s.manipulate(1, t.Unit.month), s.date = +e.dataset.day; let i = 0; this.optionsStore.options.multipleDates ? -1 !== (i = this.dates.pickedIndex(s, t.Unit.date)) ? this.dates.setValue(null, i) : this.dates.setValue(s, this.dates.lastPickedIndex + 1) : this.dates.setValue(s, this.dates.lastPickedIndex), this.display._hasTime || this.optionsStore.options.display.keepOpen || this.optionsStore.options.display.inline || this.optionsStore.options.multipleDates || this.display.hide() } }), e || r.errorMessages.mustProvideElement(), this.optionsStore.element = e, this._initializeOptions(s, m, !0), this.optionsStore.viewDate.setLocale(this.optionsStore.options.localization.locale), this.optionsStore.unset = !0, this._initializeInput(), this._initializeToggle(), this.optionsStore.options.display.inline && this.display.show(), this._eventEmitters.triggerEvent.subscribe(t => { this._triggerEvent(t) }), this._eventEmitters.viewUpdate.subscribe(() => { this._viewUpdate() }), this._eventEmitters.updateViewDate.subscribe(t => { this.viewDate = t }) } get viewDate() { return this.optionsStore.viewDate } set viewDate(t) { this.optionsStore.viewDate = t, this.optionsStore.viewDate.setLocale(this.optionsStore.options.localization.locale), this.display._update("clock" === this.optionsStore.currentView ? "clock" : "calendar") } updateOptions(t, e = !1) { e ? this._initializeOptions(t, m) : this._initializeOptions(t, this.optionsStore.options), this.display._rebuild() } toggle() { this._isDisabled || this.display.toggle() } show() { this._isDisabled || this.display.show() } hide() { this.display.hide() } disable() { this._isDisabled = !0, this.optionsStore.input?.setAttribute("disabled", "disabled"), this.display.hide() } enable() { this._isDisabled = !1, this.optionsStore.input?.removeAttribute("disabled") } clear() { this.optionsStore.input.value = "", this.dates.clear() } subscribe(t, e) { "string" == typeof t && (t = [t]); let s; s = Array.isArray(e) ? e : [e], t.length !== s.length && r.errorMessages.subscribeMismatch(); let i = []; for (let o = 0; o < t.length; o++) { let a = t[o]; if (Array.isArray(this._subscribers[a]) || (this._subscribers[a] = []), this._subscribers[a].push(s[o]), i.push({ unsubscribe: this._unsubscribe.bind(this, a, this._subscribers[a].length - 1) }), 1 === t.length) return i[0] } return i } dispose() { this.display.hide(), this.display._dispose(), this._eventEmitters.destroy(), this.optionsStore.input?.removeEventListener("change", this._inputChangeEvent), this.optionsStore.options.allowInputToggle && this.optionsStore.input?.removeEventListener("click", this._toggleClickEvent), this._toggle?.removeEventListener("click", this._toggleClickEvent), this._subscribers = {} } locale(t) { let e = x[t]; e && this.updateOptions({ localization: e }) } _triggerEvent(t) { t.viewMode = this.optionsStore.currentView; let e = t.type === r.events.change; if (e) { let { date: s, oldDate: i, isClear: o } = t; if (s && i && s.isSame(i) || !o && !s && !i) return; this._handleAfterChangeEvent(t), this.optionsStore.input?.dispatchEvent(new CustomEvent(t.type, { detail: t })), this.optionsStore.input?.dispatchEvent(new CustomEvent("change", { detail: t })) } if (this.optionsStore.element.dispatchEvent(new CustomEvent(t.type, { detail: t })), window.jQuery) { let a = window.jQuery; e && this.optionsStore.input ? a(this.optionsStore.input).trigger(t) : a(this.optionsStore.element).trigger(t) } this._publish(t) } _publish(t) { Array.isArray(this._subscribers[t.type]) && this._subscribers[t.type].forEach(e => { e(t) }) } _viewUpdate() { this._triggerEvent({ type: r.events.update, viewDate: this.optionsStore.viewDate.clone }) } _unsubscribe(t, e) { this._subscribers[t].splice(e, 1) } _initializeOptions(t, e, s = !1) { let o = M.deepCopy(t); o = M._mergeOptions(o, e), s && (o = M._dataToOptions(this.optionsStore.element, o)), M._validateConflicts(o), o.viewDate = o.viewDate.setLocale(o.localization.locale), this.optionsStore.viewDate.isSame(o.viewDate) || (this.optionsStore.viewDate = o.viewDate), o.display.components.year && (this.optionsStore.minimumCalendarViewMode = 2), o.display.components.month && (this.optionsStore.minimumCalendarViewMode = 1), o.display.components.date && (this.optionsStore.minimumCalendarViewMode = 0), this.optionsStore.currentCalendarViewMode = Math.max(this.optionsStore.minimumCalendarViewMode, this.optionsStore.currentCalendarViewMode), d[this.optionsStore.currentCalendarViewMode].name !== o.display.viewMode && (this.optionsStore.currentCalendarViewMode = Math.max(d.findIndex(t => t.name === o.display.viewMode), this.optionsStore.minimumCalendarViewMode)), this.display?.isVisible && this.display._update("all"), o.display.components.useTwentyfourHour && void 0 === o.localization.hourCycle ? o.localization.hourCycle = "h24" : void 0 === o.localization.hourCycle && (o.localization.hourCycle = i(o.localization.locale)), this.optionsStore.options = o } _initializeInput() { if ("INPUT" == this.optionsStore.element.tagName) this.optionsStore.input = this.optionsStore.element; else { let t = this.optionsStore.element.dataset.tdTargetInput; void 0 == t || "nearest" == t ? this.optionsStore.input = this.optionsStore.element.querySelector("input") : this.optionsStore.input = this.optionsStore.element.querySelector(t) } this.optionsStore.input && (!this.optionsStore.input.value && this.optionsStore.options.defaultDate && (this.optionsStore.input.value = this.dates.formatInput(this.optionsStore.options.defaultDate)), this.optionsStore.input.addEventListener("change", this._inputChangeEvent), this.optionsStore.options.allowInputToggle && this.optionsStore.input.addEventListener("click", this._toggleClickEvent), this.optionsStore.input.value && this._inputChangeEvent()) } _initializeToggle() { if (this.optionsStore.options.display.inline) return; let t = this.optionsStore.element.dataset.tdTargetToggle; "nearest" == t && (t = '[data-td-toggle="datetimepicker"]'), this._toggle = void 0 == t ? this.optionsStore.element : this.optionsStore.element.querySelector(t), this._toggle.addEventListener("click", this._toggleClickEvent) } _handleAfterChangeEvent(t) { !this.optionsStore.options.promptTimeOnDateChange || this.optionsStore.options.display.inline || this.optionsStore.options.display.sideBySide || !this.display._hasTime || this.display.widget?.getElementsByClassName(r.css.show)[0].classList.contains(r.css.timeContainer) || !t.oldDate && this.optionsStore.options.useCurrent || t.oldDate && t.date?.isSame(t.oldDate) || (clearTimeout(this._currentPromptTimeTimeout), this._currentPromptTimeTimeout = setTimeout(() => { this.display.widget && this._eventEmitters.action.emit({ e: { currentTarget: this.display.widget.querySelector(`.${r.css.switch}`) }, action: A.togglePicker }) }, this.optionsStore.options.promptTimeOnDateChangeTransitionDelay)) } } let x = {}, P = t => { x[t.name] || (x[t.name] = t.localization) }, I = t => { let e = x[t]; e && (m.localization = e) }, z = function (t, e) { return t && (t.installed || (t(e, { TempusDominus: O, Dates: L, Display: H, DateTime: o, Namespace: r }, B), t.installed = !0)), B }, N = "6.2.9", B = { TempusDominus: O, extend: z, loadLocale: P, locale: I, Namespace: r, DefaultOptions: m, DateTime: o, Unit: t.Unit, version: N }; t.DateTime = o, t.DefaultOptions = m, t.Namespace = r, t.TempusDominus = O, t.extend = z, t.loadLocale = P, t.locale = I, t.version = N, Object.defineProperty(t, "__esModule", { value: !0 }) });